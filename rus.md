# Стрелочные функции и bind()

Cтрелочные функции в ES6 часто рассматривают как альтернативу `Function.prototype.bind()`.

## 1. Извлечение методов

Если извлечённый метод используется как коллбек, вы должны определить `this`, 
в противном случае он будет вызван как функция (и `this` будет `undefined` 
или указывать на глобальную область видимости). Например: 

    obj.on('anEvent', console.log.bind(console))
    
В качестве альтернативы можно использовать стрелочную функцию:

    obj.on('anEvent', x => console.log(x))
    

## 2. Передача `this` в качестве параметра

Следующий код демонстрирует хитрый трюк: в некоторых методах не нужно использовать 
`bind()` передавая их в качестве колбека, его можно задать в качестве дополнительного
параметра. Один из таких методов — `filter()`:

    const as = new Set([1, 2, 3]);
    const bs = new Set([3, 2, 4]);
    const intersection = [...as].filter(bs.has, bs);
    // [2, 3]
    
Однако, этот код становится легче понять, если использовать стрелочную функцию:

    const as = new Set([1, 2, 3]);
    const bs = new Set([3, 2, 4]);
    const intersection = [...as].filter(a => bs.has(a));
    // [2, 3]
    

## 3. Частичные вычисления

`bind()` позволяет производить [*частичные вычисления*][1], можно создавать
новые функции, определяя параметры исходной: 

    function add(x, y) {
        return x + y;
    }
    const plus1 = add.bind(undefined, 1);

И опять таки, мне кажется, что использование стрелочной функции делает
код понятнее:

    const plus1 = y => add(1, y);
    

## 4. Ссылки для дальнейшего изучения 

* [Каррирование и частичные вычисления (в JavaScript)][1]
* [Декаррирование в JavaScript][2]

 [1]: http://www.2ality.com/2011/09/currying-vs-part-eval.html
 [2]: http://www.2ality.com/2011/11/uncurrying-this.html
